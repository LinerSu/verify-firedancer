#include <nondet.h>
#include <proof_allocators.h>
#include <sea_allocators.h>
#include <seahorn/seahorn.h>
#include <utils.h>

#include "stubs/fd_tls_helper.h"
#include "waltz/tls/fd_tls.h"

void *tls_rand_ctx = NULL;
void *fd_tls_sign_ctx = NULL;

// Model server tls
#define TLS_HS_SEQ_LEN 5
/*
    Client                                        Server
    ------                                        ------
      |                                             |
      |  ClientHello (1)                            |
      |-------------------------------------------->|
      |                                             |
      |               ServerHello (2)               |
      |<--------------------------------------------|
      |                                             |
      |               EncryptedExtensions (3)       |
      |               Certificate (4)               |
      |               CertificateVerify (5)         |
      |               Finished (6)                  |
      |<--------------------------------------------|
      |                                             |
      |  Finished (7)                               |
      |-------------------------------------------->|
      |                                             |
      |<== Application Data (encrypted) ==â†’>|       |
      |                                             |
 */
static const int fd_tls_hs_server_sequence[] = {
  FD_TLS_HS_START,
  FD_TLS_HS_WAIT_CERT,
  FD_TLS_HS_WAIT_CV,
  FD_TLS_HS_WAIT_FINISHED,
  FD_TLS_HS_CONNECTED,
};

int main(void) {
  fd_tls_t l_tls = {0};
  fd_tls_t *tls = fd_tls_join(fd_tls_new(&l_tls));
  if (!tls)
    return 0;

  fd_rng_t rng = { .seq = 0UL, .idx = 0UL };
  tls_rand_ctx = &rng;
  fd_tls_sign_ctx = &rng;

  tls->rand = (fd_tls_rand_t){.ctx = tls_rand_ctx, .rand_fn = tls_rand};
  tls->secrets_fn = tls_secrets;
  tls->sendmsg_fn = tls_sendmsg;
  tls->sign = (fd_tls_sign_t){.ctx = fd_tls_sign_ctx,
                              .sign_fn = fd_tls_sign_fn};
  if (tls->quic) {
    tls->quic_tp_self_fn = tls_quic_tp_self;
    tls->quic_tp_peer_fn = tls_quic_tp_peer;
  }

  assume(tls->cert_x509_sz == 0x00UL || /* No x509 */
                   tls->cert_x509_sz ==
                       0xf4UL); /* Cert size generated by fd_x509_mock */
  memcpy(tls->alpn, "\xasolana-tpu", 11UL);
  tls->alpn_sz = 11UL;

  fd_tls_estate_srv_t hs_[1];
  fd_tls_estate_srv_t * hs = fd_tls_estate_srv_new( hs_ );

  for (int i = 0; i < TLS_HS_SEQ_LEN; i++) {
    ulong record_sz = nd_ulong();
    assume(record_sz > 0UL && record_sz < 128UL);
    uchar *record = bounded_malloc_havoc(record_sz);
    uint enc_level = nd_uint();
    assume(enc_level <= 3);

    long res = fd_tls_server_handshake(tls, hs, record, record_sz, enc_level);
    if (res < 0L)
      return 0;
  }
  sassert(hs->base.state == FD_TLS_HS_CONNECTED);

  fd_tls_estate_srv_delete(hs);
  free(fd_tls_delete(fd_tls_leave(tls)));
  return 0;
}
