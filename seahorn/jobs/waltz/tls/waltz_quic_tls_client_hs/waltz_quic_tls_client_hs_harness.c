#include <nondet.h>
#include <proof_allocators.h>
#include <sea_allocators.h>
#include <seahorn/seahorn.h>
#include <utils.h>

#include "waltz/tls/fd_tls.h"
#include "stubs/fd_tls_helper.h"

void *tls_rand_ctx = NULL;
void *fd_tls_sign_ctx = NULL;

// Model client tls
#define TLS_HS_SEQ_LEN 7
/*
    Client                                        Server
    ------                                        ------
      |                                             |
      |  ClientHello (1)                            |
      |-------------------------------------------->|
      |                                             |
      |               ServerHello (2)               |
      |<--------------------------------------------|
      |                                             |
      |               EncryptedExtensions (3)       |
      |               Certificate (4)               |
      |               CertificateVerify (5)         |
      |               Finished (6)                  |
      |<--------------------------------------------|
      |                                             |
      |  Finished (7)                               |
      |-------------------------------------------->|
      |                                             |
      |<== Application Data (encrypted) ==â†’>|       |
      |                                             |
 */
static const uint8_t tls_client_hs_sequence[TLS_HS_SEQ_LEN] = {
    FD_TLS_HS_START,         /* sent ClientHello */
    FD_TLS_HS_WAIT_SH,       /* waiting for ServerHello */
    FD_TLS_HS_WAIT_EE,       /* waiting for EncryptedExtensions */
    FD_TLS_HS_WAIT_CERT,     /* waiting for Certificate */
    FD_TLS_HS_WAIT_CV,       /* waiting for CertificateVerify */
    FD_TLS_HS_WAIT_FINISHED, /* waiting for Finished */
    FD_TLS_HS_CONNECTED      /* handshake complete */
};

int main(void) {
  fd_tls_t l_tls = {0};
  fd_tls_t *tls = fd_tls_join(fd_tls_new(&l_tls));
  if (!tls)
    return 0;

  fd_rng_t rng = { .seq = 0UL, .idx = 0UL };
  tls_rand_ctx = &rng;
  fd_tls_sign_ctx = &rng;

  tls->rand = (fd_tls_rand_t){.ctx = tls_rand_ctx, .rand_fn = tls_rand};
  tls->secrets_fn = tls_secrets;
  tls->sendmsg_fn = tls_sendmsg;
  tls->sign = (fd_tls_sign_t){.ctx = fd_tls_sign_ctx,
                              .sign_fn = fd_tls_sign_fn};
  if (tls->quic) {
    tls->quic_tp_self_fn = tls_quic_tp_self;
    tls->quic_tp_peer_fn = tls_quic_tp_peer;
  }

  assume(tls->cert_x509_sz == 0x00UL || /* No x509 */
                   tls->cert_x509_sz ==
                       0xf4UL); /* Cert size generated by fd_x509_mock */
  memcpy(tls->alpn, "\xasolana-tpu", 11UL);
  tls->alpn_sz = 11UL;

  fd_tls_estate_cli_t hs_[1];
  fd_tls_estate_cli_t *hs = fd_tls_estate_cli_new(hs_);

  // for (int i = 0; i < TLS_HS_SEQ_LEN; i++) {
  //   hs->base.state = tls_client_hs_sequence[i];
    ulong record_sz = nd_ulong();
    assume(record_sz > 0UL && record_sz < 2048UL);
    uchar *record = bounded_malloc_havoc(record_sz);
    uint enc_level = nd_uint();
    assume(enc_level <= 3);

    long res = fd_tls_client_handshake(tls, hs, record, record_sz, enc_level);
    if (res < 0L)
      return 0;
  // }
  // sassert(hs->base.state == FD_TLS_HS_CONNECTED);

  fd_tls_estate_cli_delete(hs);
  free(fd_tls_delete(fd_tls_leave(tls)));
  return 0;
}
